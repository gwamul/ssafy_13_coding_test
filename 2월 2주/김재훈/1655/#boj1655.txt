#boj1655

## 의식의 흐름 기법
1. 정렬 후 찾기
시간상 안됨.

2. 즉, 매번 넣을 때마다 중간값을 거의 바로 계산 가능해야 한다. 

배열 만들어 놓고
arr[20001] 해당 배열 인덱스(정수+10000) 가 몇개인지 저장

변수는 mid를 저장해 놓고 새로 들어오는 수가 mid보다 큰지 , 작은지 , 같은지 판단해서 좌우에 몇개인지 판단, 
-> 새로운 mid 인덱스를 알수 있음 (이거는 for문이지만 바로 옆자리기 때문에 괜찮나?)

---
그럼 최악은 -10000와 10000를 번갈아 가며 하는 경우? 

 그러면 이중 배열로 바꾸고 해당 수의 양옆으로 있는 수를 저장?
그럼 바로 이동 가능 => 이거다!

=================
너무 복잡하다. 
int[][] nums = new int[20001][3]; // {숫자, 좌, 우} 양 옆에 있는 숫자 인덱스 저장
-> 배열을 선언하는건 그렇다 치는데 새로운 숫자가 들어올 때마다 3개의 인덱스의 값을 변경해야 하는데 이때 for문을 돌아서 좀 애매..
=-=============

PriorityQueue - mid - PriorityQueue이러면?
오른쪽꺼는 reverse

------------------------------------------------------------------
위 처럼 말고 어떤 논리로 방법을 찾을 수 있을까?
1. 문제 지문

일단, 새로운 숫자가 들어오는 동시에 값을 계산 가능해야 하는 건 맞다.

-> 그냥 이런 중간값의 양옆을 정렬하는 유형을 암기?

2. 시간 복잡도
2*N*logN => 100만 정도
충분.
